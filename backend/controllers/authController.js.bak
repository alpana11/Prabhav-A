const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Officer = require('../models/Officer');
const otpService = require('../services/otpService');
const logger = require('../logger');

/**
 * POST /api/auth/send-otp
 * Send OTP to user's phone number
 */
exports.sendOtp = async (req, res) => {
  try {
    const { aadhar, phone } = req.body;

    // Validate input: aadhar is required; phone is optional (we'll try to fetch it)
    if (!aadhar) {
      return res.status(400).json({
        success: false,
        message: 'Aadhar number is required',
      });
    }

    // Validate Aadhar (12 digits)
    const cleanAadhar = aadhar.replace(/\s/g, '');
    if (!/^\d{12}$/.test(cleanAadhar)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid Aadhar number (must be 12 digits)',
      });
    }

    // Determine phone number: prefer provided phone, otherwise try to lookup from DB
    let cleanPhone = phone ? phone.replace(/\D/g, '') : null;
    /**
     * POST /api/auth/verify-otp
     * Verify Firebase ID token (from Firebase Phone Auth)
     * Server-side verification using Firebase Admin SDK
     * Links Firebase UID to user in MongoDB
     */
    exports.verifyOtp = async (req, res) => {
      try {
        const { aadhar, idToken } = req.body;

        if (!aadhar) {
          return res.status(400).json({ success: false, message: 'Aadhar is required' });
        }

        if (!idToken) {
          return res.status(400).json({ success: false, message: 'Firebase ID token is required' });
        }

        const cleanAadhar = aadhar.replace(/\s/g, '');

        try {
          // Verify Firebase ID token using Admin SDK
          const admin = require('firebase-admin');
          if (!admin.apps || admin.apps.length === 0) {
            try {
              const firebaseService = require('../services/firebaseService');
              await firebaseService.initFirebase();
            } catch (ie) {
              logger.error('[AUTH] Firebase init failed:', ie.message);
              return res.status(500).json({ success: false, message: 'Firebase not initialized' });
            }
          }
    // If client provided a Firebase ID token (from Firebase phone auth), verify it and mark OTP.
          logger.info(`[AUTH] Verifying Firebase ID token for Aadhar: ${cleanAadhar}`);
          const decoded = await admin.auth().verifyIdToken(idToken);
      
          const firebaseUid = decoded.uid;
          const phoneNumber = decoded.phone_number || '';
    if (firebaseIdToken) {
          if (!firebaseUid) {
            logger.warn(`[AUTH] Firebase token has no UID`);
            return res.status(400).json({ success: false, message: 'Firebase token invalid: no UID' });
          }
      try {
          logger.info(`[AUTH] Firebase token verified successfully for UID: ${firebaseUid}, Phone: ${phoneNumber}`);
        // Ensure firebase admin is initialized
          // Link user: find or create user and attach Firebase UID
          let user = await User.findByAadhar(cleanAadhar);
          if (user) {
            // Update existing user with Firebase UID and phone
            user.firebaseUid = firebaseUid;
            if (phoneNumber && !user.phone) {
              user.phone = phoneNumber;
            }
            user.verified = true;
            user.verifiedAt = new Date();
            await user.save();
            logger.info(`[AUTH] Linked existing user to Firebase UID: ${firebaseUid}`);
          } else {
            // Create new user with Firebase UID
            user = new User({
              aadhar: cleanAadhar,
              firebaseUid,
              phone: phoneNumber,
              verified: true,
              verifiedAt: new Date(),
            });
            await user.save();
            logger.info(`[AUTH] Created new user linked to Firebase UID: ${firebaseUid}`);
          }
        const admin = require('firebase-admin');
          // Create temp token for set-password flow
          const tempToken = jwt.sign(
            { aadhar: cleanAadhar, firebaseUid, verified: 'otp' },
            process.env.JWT_SECRET || 'dev-secret',
            { expiresIn: '15m' }
          );
        if (!admin.apps || admin.apps.length === 0) {
          return res.json({
            success: true,
            message: 'Firebase phone verification successful',
            tempToken,
            userId: user._id,
            firebaseUid,
          });
        } catch (e) {
          logger.error(`[AUTH] Firebase token verification error: ${e.code} - ${e.message}`);
          return res.status(401).json({
            success: false,
            message: `Firebase verification failed: ${e.message}`,
          });
        }
      } catch (error) {
        logger.error(`[AUTH] verifyOtp error: ${error.message}`);
        res.status(500).json({ success: false, message: 'Error verifying OTP' });
      }
    };

    // OLD CODE (kept for reference, commented out)
    /*
        // Fallback: traditional OTP verification (server-side code match)
        if (!otp) {
          return res.status(400).json({ success: false, message: 'OTP is required when not using Firebase verification' });
        }
          try {
        const result = await otpService.verifyOtp(cleanAadhar, otp);
        if (!result.success) {
          return res.status(400).json({ success: false, message: result.message, attempts: result.attempts });
        }
            const firebaseService = require('../services/firebaseService');
        logger.info(`[AUTH] OTP verified for Aadhar: ${cleanAadhar}`);
        const tempToken = jwt.sign({ aadhar: cleanAadhar, verified: 'otp' }, process.env.JWT_SECRET || 'dev-secret', { expiresIn: '15m' });
        res.json({ success: true, message: 'OTP verified successfully', tempToken });
            await firebaseService.initFirebase();
          } catch (ie) {
            // continue - init may log its own errors
          }
        }
        const decoded = await admin.auth().verifyIdToken(firebaseIdToken);
        const phone = decoded.phone_number;
        if (!phone) {
          return res.status(400).json({ success: false, message: 'Firebase token does not contain phone information' });
        }

        const result = await otpService.verifyWithPhone(cleanAadhar, phone);
        if (!result.success) {
          return res.status(400).json({ success: false, message: result.message });
        }

        logger.info(`[AUTH] OTP verified via Firebase for Aadhar: ${cleanAadhar}`);

        const tempToken = jwt.sign({ aadhar: cleanAadhar, verified: 'otp' }, process.env.JWT_SECRET || 'dev-secret', { expiresIn: '15m' });
        return res.json({ success: true, message: 'OTP verified successfully', tempToken });
      } catch (e) {
        logger.error(`[AUTH] Firebase token verification failed: ${e.message}`);
        return res.status(400).json({ success: false, message: 'Invalid Firebase token' });
      }
    }

    // Fallback: traditional OTP verification (server-side code match)
    if (!otp) {
      return res.status(400).json({ success: false, message: 'OTP is required when not using Firebase verification' });
    }

    const result = await otpService.verifyOtp(cleanAadhar, otp);
    if (!result.success) {
      return res.status(400).json({ success: false, message: result.message, attempts: result.attempts });
    }

    logger.info(`[AUTH] OTP verified for Aadhar: ${cleanAadhar}`);
    const tempToken = jwt.sign({ aadhar: cleanAadhar, verified: 'otp' }, process.env.JWT_SECRET || 'dev-secret', { expiresIn: '15m' });
    res.json({ success: true, message: 'OTP verified successfully', tempToken });
  } catch (error) {
    logger.error(`[AUTH] verifyOtp error: ${error.message}`);
    res.status(500).json({ success: false, message: 'Error verifying OTP' });
  }
};

/**
 * POST /api/auth/set-password
 * Set password after OTP verification
 */
exports.setPassword = async (req, res) => {
  try {
    const { aadhar, password, confirmPassword } = req.body;
    const tempToken = req.headers.authorization?.split(' ')[1];

    if (!aadhar || !password) {
      return res.status(400).json({
        success: false,
        message: 'Aadhar and password are required',
      });
    }

    if (password !== confirmPassword) {
      return res.status(400).json({
        success: false,
        message: 'Passwords do not match',
      });
    }

    if (password.length < 8) {
      return res.status(400).json({
        success: false,
        message: 'Password must be at least 8 characters long',
      });
    }

    // Verify temp token
    if (!tempToken) {
      return res.status(401).json({
        success: false,
        message: 'OTP verification required first',
      });
    }

    try {
      const decoded = jwt.verify(
        tempToken,
        process.env.JWT_SECRET || 'dev-secret'
      );
      if (decoded.aadhar !== aadhar.replace(/\s/g, '') || decoded.verified !== 'otp') {
        throw new Error('Invalid token');
      }
    } catch (err) {
      return res.status(401).json({
        success: false,
        message: 'Invalid or expired OTP verification token',
      });
    }

    const cleanAadhar = aadhar.replace(/\s/g, '');

    // Check if user exists
    let user = await User.findByAadhar(cleanAadhar);

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    if (user) {
      // Update existing user
      user.password = hashedPassword;
      user.passwordSetAt = new Date();
      await user.save();
      logger.info(`[AUTH] Password updated for Aadhar: ${cleanAadhar}`);
    } else {
      // Create new user
      user = new User({
        aadhar: cleanAadhar,
        password: hashedPassword,
        passwordSetAt: new Date(),
      });
      const savedUser = await user.save();
      logger.info(`[AUTH] New user created for Aadhar: ${cleanAadhar}, MongoDB ID: ${savedUser._id}`);
    }

    // Clear OTP
    await otpService.clearOtp(cleanAadhar);

    res.json({
      success: true,
      message: 'Password set successfully',
      userId: user._id,
    });
  } catch (error) {
    logger.error(`[AUTH] setPassword error: ${error.message}`);
    res.status(500).json({
      success: false,
      message: 'Error setting password',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined,
    });
  }
};

/**
 * POST /api/auth/set-username
 * Set username after OTP/password setup
 */
exports.setUsername = async (req, res) => {
  try {
    const { aadhar, username } = req.body;

    if (!aadhar || !username) {
      return res.status(400).json({
        success: false,
        message: 'Aadhar and username are required',
      });
    }

    if (username.length < 3) {
      return res.status(400).json({
        success: false,
        message: 'Username must be at least 3 characters',
      });
    }

    const cleanAadhar = aadhar.replace(/\s/g, '');

    // Check username uniqueness
      // Find current user by Aadhar
      const user = await User.findByAadhar(cleanAadhar);
      if (!user) {
        return res.status(404).json({ success: false, message: 'User not found' });
      }

      // Check username uniqueness using lowercased index; allow if it's the same user
      const existing = await User.findOne({ usernameLower: username.toLowerCase() });
      if (existing && existing._id.toString() !== user._id.toString()) {
        return res.status(400).json({ success: false, message: 'Username already taken' });
      }

      user.username = username;
      user.usernameSetAt = new Date();
      await user.save();

    logger.info(`[AUTH] Username set for ${cleanAadhar}: ${username}`);

    res.json({
      success: true,
      message: 'Username set successfully',
    });
  } catch (error) {
    logger.error(`[AUTH] setUsername error: ${error.message}`);
    res.status(500).json({
      success: false,
      message: 'Error setting username',
    });
  }
};

/**
 * POST /api/auth/login
 * Login with Aadhar and password
 */
exports.login = async (req, res) => {
  try {
    const { aadhar, password } = req.body;

    if (!aadhar || !password) {
      return res.status(400).json({
        success: false,
        message: 'Aadhar and password are required',
      });
    }

    const cleanAadhar = aadhar.replace(/\s/g, '');

    // Find user
    const user = await User.findByAadhar(cleanAadhar);
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid Aadhar or password',
      });
    }

    // Check password
    const passwordMatch = await bcrypt.compare(password, user.password);
    if (!passwordMatch) {
      return res.status(401).json({
        success: false,
        message: 'Invalid Aadhar or password',
      });
    }

    // Create JWT token
    const token = jwt.sign(
      { userId: user._id, aadhar: user.aadhar },
      process.env.JWT_SECRET || 'dev-secret',
      { expiresIn: '30d' }
    );

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    logger.info(`[AUTH] Login successful for ${cleanAadhar}`);

    res.json({
      success: true,
      message: 'Login successful',
      token,
      user: {
        id: user._id,
        aadhar: user.aadhar,
        username: user.username,
        profilePic: user.profilePic,
      },
    });
  } catch (error) {
    logger.error(`[AUTH] login error: ${error.message}`);
    res.status(500).json({
      success: false,
      message: 'Error logging in',
    });
  }
};

/**
 * GET /api/auth/me
 * Get current user info (requires auth)
 */
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found',
      });
    }

    res.json({
      success: true,
      user: {
        id: user._id,
        aadhar: user.aadhar,
        username: user.username,
        phone: user.phone,
        email: user.email,
        profilePic: user.profilePic,
        location: user.currentLocation,
        createdAt: user.createdAt,
      },
    });
  } catch (error) {
    logger.error(`[AUTH] getMe error: ${error.message}`);
    res.status(500).json({
      success: false,
      message: 'Error fetching user info',
    });
  }
};


exports.officerLogin = async (req, res) => {
  const schema = Joi.object({ officerId: Joi.string().required(), password: Joi.string().required() });
  const { error } = schema.validate(req.body);
  if (error) return res.status(400).json({ message: error.message });
  const { officerId, password } = req.body;
  try {
    const officer = await Officer.findOne({ officerId });
    if (!officer) return res.status(401).json({ message: 'Invalid credentials' });
    
    const match = await officer.comparePassword(password);
    if (!match) return res.status(401).json({ message: 'Invalid credentials' });
    
    const token = jwt.sign({ id: officer._id, role: 'officer', department: officer.department }, process.env.JWT_SECRET || 'secret', { expiresIn: process.env.JWT_EXPIRES_IN || '7d' });
    res.json({ message: 'Login successful', token, officer: { id: officer._id, officerId: officer.officerId, name: officer.name, department: officer.department } });
  } catch (err) {
    return res.status(500).json({ message: 'Error logging in' });
  }
};

exports.adminLogin = async (req, res) => {
  const schema = Joi.object({ username: Joi.string().required(), password: Joi.string().required() });
  const { error } = schema.validate(req.body);
  if (error) return res.status(400).json({ message: error.message });
  const { username, password } = req.body;
  try {
    if (username === process.env.ADMIN_USER && password === process.env.ADMIN_PASS) {
      const token = jwt.sign({ role: 'admin', username }, process.env.JWT_SECRET || 'secret', { expiresIn: process.env.JWT_EXPIRES_IN || '7d' });
      return res.json({ message: 'Admin login successful', token });
    }
    return res.status(401).json({ message: 'Invalid admin credentials' });
  } catch (err) {
    return res.status(500).json({ message: 'Error logging in' });
  }
};
